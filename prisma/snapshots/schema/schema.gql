# -----------------------------------------------
# !!! THIS FILE WAS GENERATED BY TYPE-GRAPHQL !!!
# !!!   DO NOT MODIFY THIS FILE BY YOURSELF   !!!
# -----------------------------------------------

type AffectedRowsOutput {
  count: Int!
}

type AggregateCategory {
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
}

type AggregateOffer {
  _avg: OfferAvgAggregate
  _count: OfferCountAggregate
  _max: OfferMaxAggregate
  _min: OfferMinAggregate
  _sum: OfferSumAggregate
}

type AggregateOrder {
  _avg: OrderAvgAggregate
  _count: OrderCountAggregate
  _max: OrderMaxAggregate
  _min: OrderMinAggregate
  _sum: OrderSumAggregate
}

type AggregateOrderItem {
  _avg: OrderItemAvgAggregate
  _count: OrderItemCountAggregate
  _max: OrderItemMaxAggregate
  _min: OrderItemMinAggregate
  _sum: OrderItemSumAggregate
}

type AggregateProduct {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
}

type AggregateUser {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
}

type AggregateUserProvider {
  _count: UserProviderCountAggregate
  _max: UserProviderMaxAggregate
  _min: UserProviderMinAggregate
}

type Category {
  _count: CategoryCount
  childCategories: [Category]
  children(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  id: String!
  name: String!
  parent: Category
  parentCategory: Category
  parentId: String
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
}

type CategoryCount {
  children: Int!
  products: Int!
}

type CategoryCountAggregate {
  _all: Int!
  id: Int!
  name: Int!
  parentId: Int!
}

input CategoryCountOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  parentId: SortOrder
}

input CategoryCreateInput {
  children: CategoryCreateNestedManyWithoutParentInput
  id: String
  name: String!
  parent: CategoryCreateNestedOneWithoutChildrenInput
  products: ProductCreateNestedManyWithoutCategoryInput
}

input CategoryCreateManyInput {
  id: String
  name: String!
  parentId: String
}

input CategoryCreateManyParentInput {
  id: String
  name: String!
}

input CategoryCreateManyParentInputEnvelope {
  data: [CategoryCreateManyParentInput!]!
  skipDuplicates: Boolean
}

input CategoryCreateNestedManyWithoutParentInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutParentInput!]
  create: [CategoryCreateWithoutParentInput!]
  createMany: CategoryCreateManyParentInputEnvelope
}

input CategoryCreateNestedOneWithoutChildrenInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutChildrenInput
  create: CategoryCreateWithoutChildrenInput
}

input CategoryCreateNestedOneWithoutProductsInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutProductsInput
  create: CategoryCreateWithoutProductsInput
}

input CategoryCreateOrConnectWithoutChildrenInput {
  create: CategoryCreateWithoutChildrenInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateOrConnectWithoutParentInput {
  create: CategoryCreateWithoutParentInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateOrConnectWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput!
  where: CategoryWhereUniqueInput!
}

input CategoryCreateWithoutChildrenInput {
  id: String
  name: String!
  parent: CategoryCreateNestedOneWithoutChildrenInput
  products: ProductCreateNestedManyWithoutCategoryInput
}

input CategoryCreateWithoutParentInput {
  children: CategoryCreateNestedManyWithoutParentInput
  id: String
  name: String!
  products: ProductCreateNestedManyWithoutCategoryInput
}

input CategoryCreateWithoutProductsInput {
  children: CategoryCreateNestedManyWithoutParentInput
  id: String
  name: String!
  parent: CategoryCreateNestedOneWithoutChildrenInput
}

type CategoryGroupBy {
  _count: CategoryCountAggregate
  _max: CategoryMaxAggregate
  _min: CategoryMinAggregate
  id: String!
  name: String!
  parentId: String
}

input CategoryListRelationFilter {
  every: CategoryWhereInput
  none: CategoryWhereInput
  some: CategoryWhereInput
}

type CategoryMaxAggregate {
  id: String
  name: String
  parentId: String
}

input CategoryMaxOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  parentId: SortOrder
}

type CategoryMinAggregate {
  id: String
  name: String
  parentId: String
}

input CategoryMinOrderByAggregateInput {
  id: SortOrder
  name: SortOrder
  parentId: SortOrder
}

input CategoryOrderByRelationAggregateInput {
  _count: SortOrder
}

input CategoryOrderByWithAggregationInput {
  _count: CategoryCountOrderByAggregateInput
  _max: CategoryMaxOrderByAggregateInput
  _min: CategoryMinOrderByAggregateInput
  id: SortOrder
  name: SortOrder
  parentId: SortOrder
}

input CategoryOrderByWithRelationInput {
  children: CategoryOrderByRelationAggregateInput
  id: SortOrder
  name: SortOrder
  parent: CategoryOrderByWithRelationInput
  parentId: SortOrder
  products: ProductOrderByRelationAggregateInput
}

input CategoryRelationFilter {
  is: CategoryWhereInput
  isNot: CategoryWhereInput
}

enum CategoryScalarFieldEnum {
  id
  name
  parentId
}

input CategoryScalarWhereInput {
  AND: [CategoryScalarWhereInput!]
  NOT: [CategoryScalarWhereInput!]
  OR: [CategoryScalarWhereInput!]
  id: StringFilter
  name: StringFilter
  parentId: StringNullableFilter
}

input CategoryScalarWhereWithAggregatesInput {
  AND: [CategoryScalarWhereWithAggregatesInput!]
  NOT: [CategoryScalarWhereWithAggregatesInput!]
  OR: [CategoryScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  parentId: StringNullableWithAggregatesFilter
}

input CategoryUpdateInput {
  children: CategoryUpdateManyWithoutParentNestedInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parent: CategoryUpdateOneWithoutChildrenNestedInput
  products: ProductUpdateManyWithoutCategoryNestedInput
}

input CategoryUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
}

input CategoryUpdateManyWithWhereWithoutParentInput {
  data: CategoryUpdateManyMutationInput!
  where: CategoryScalarWhereInput!
}

input CategoryUpdateManyWithoutParentNestedInput {
  connect: [CategoryWhereUniqueInput!]
  connectOrCreate: [CategoryCreateOrConnectWithoutParentInput!]
  create: [CategoryCreateWithoutParentInput!]
  createMany: CategoryCreateManyParentInputEnvelope
  delete: [CategoryWhereUniqueInput!]
  deleteMany: [CategoryScalarWhereInput!]
  disconnect: [CategoryWhereUniqueInput!]
  set: [CategoryWhereUniqueInput!]
  update: [CategoryUpdateWithWhereUniqueWithoutParentInput!]
  updateMany: [CategoryUpdateManyWithWhereWithoutParentInput!]
  upsert: [CategoryUpsertWithWhereUniqueWithoutParentInput!]
}

input CategoryUpdateOneRequiredWithoutProductsNestedInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutProductsInput
  create: CategoryCreateWithoutProductsInput
  update: CategoryUpdateWithoutProductsInput
  upsert: CategoryUpsertWithoutProductsInput
}

input CategoryUpdateOneWithoutChildrenNestedInput {
  connect: CategoryWhereUniqueInput
  connectOrCreate: CategoryCreateOrConnectWithoutChildrenInput
  create: CategoryCreateWithoutChildrenInput
  delete: Boolean
  disconnect: Boolean
  update: CategoryUpdateWithoutChildrenInput
  upsert: CategoryUpsertWithoutChildrenInput
}

input CategoryUpdateWithWhereUniqueWithoutParentInput {
  data: CategoryUpdateWithoutParentInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpdateWithoutChildrenInput {
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parent: CategoryUpdateOneWithoutChildrenNestedInput
  products: ProductUpdateManyWithoutCategoryNestedInput
}

input CategoryUpdateWithoutParentInput {
  children: CategoryUpdateManyWithoutParentNestedInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  products: ProductUpdateManyWithoutCategoryNestedInput
}

input CategoryUpdateWithoutProductsInput {
  children: CategoryUpdateManyWithoutParentNestedInput
  id: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  parent: CategoryUpdateOneWithoutChildrenNestedInput
}

input CategoryUpsertWithWhereUniqueWithoutParentInput {
  create: CategoryCreateWithoutParentInput!
  update: CategoryUpdateWithoutParentInput!
  where: CategoryWhereUniqueInput!
}

input CategoryUpsertWithoutChildrenInput {
  create: CategoryCreateWithoutChildrenInput!
  update: CategoryUpdateWithoutChildrenInput!
}

input CategoryUpsertWithoutProductsInput {
  create: CategoryCreateWithoutProductsInput!
  update: CategoryUpdateWithoutProductsInput!
}

input CategoryWhereInput {
  AND: [CategoryWhereInput!]
  NOT: [CategoryWhereInput!]
  OR: [CategoryWhereInput!]
  children: CategoryListRelationFilter
  id: StringFilter
  name: StringFilter
  parent: CategoryRelationFilter
  parentId: StringNullableFilter
  products: ProductListRelationFilter
}

input CategoryWhereUniqueInput {
  id: String
}

"""
The javascript `Date` as string. Type represents date and time as the ISO Date string.
"""
scalar DateTime

input DateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input DateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input DateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input DateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input DateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input FloatFieldUpdateOperationsInput {
  decrement: Float
  divide: Float
  increment: Float
  multiply: Float
  set: Float
}

input FloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input FloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input IntFieldUpdateOperationsInput {
  decrement: Int
  divide: Int
  increment: Int
  multiply: Int
  set: Int
}

input IntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input IntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

type Mutation {
  createManyCategory(data: [CategoryCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOffer(data: [OfferCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOrder(data: [OrderCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyOrderItem(data: [OrderItemCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyProduct(data: [ProductCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUser(data: [UserCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createManyUserProvider(data: [UserProviderCreateManyInput!]!, skipDuplicates: Boolean): AffectedRowsOutput!
  createOneCategory(data: CategoryCreateInput!): Category!
  createOneOffer(data: OfferCreateInput!): Offer!
  createOneOrder(data: OrderCreateInput!): Order!
  createOneOrderItem(data: OrderItemCreateInput!): OrderItem!
  createOneProduct(data: ProductCreateInput!): Product!
  createOneUser(data: UserCreateInput!): User!
  createOneUserProvider(data: UserProviderCreateInput!): UserProvider!
  deleteManyCategory(where: CategoryWhereInput): AffectedRowsOutput!
  deleteManyOffer(where: OfferWhereInput): AffectedRowsOutput!
  deleteManyOrder(where: OrderWhereInput): AffectedRowsOutput!
  deleteManyOrderItem(where: OrderItemWhereInput): AffectedRowsOutput!
  deleteManyProduct(where: ProductWhereInput): AffectedRowsOutput!
  deleteManyUser(where: UserWhereInput): AffectedRowsOutput!
  deleteManyUserProvider(where: UserProviderWhereInput): AffectedRowsOutput!
  deleteOneCategory(where: CategoryWhereUniqueInput!): Category
  deleteOneOffer(where: OfferWhereUniqueInput!): Offer
  deleteOneOrder(where: OrderWhereUniqueInput!): Order
  deleteOneOrderItem(where: OrderItemWhereUniqueInput!): OrderItem
  deleteOneProduct(where: ProductWhereUniqueInput!): Product
  deleteOneUser(where: UserWhereUniqueInput!): User
  deleteOneUserProvider(where: UserProviderWhereUniqueInput!): UserProvider
  updateManyCategory(data: CategoryUpdateManyMutationInput!, where: CategoryWhereInput): AffectedRowsOutput!
  updateManyOffer(data: OfferUpdateManyMutationInput!, where: OfferWhereInput): AffectedRowsOutput!
  updateManyOrder(data: OrderUpdateManyMutationInput!, where: OrderWhereInput): AffectedRowsOutput!
  updateManyOrderItem(data: OrderItemUpdateManyMutationInput!, where: OrderItemWhereInput): AffectedRowsOutput!
  updateManyProduct(data: ProductUpdateManyMutationInput!, where: ProductWhereInput): AffectedRowsOutput!
  updateManyUser(data: UserUpdateManyMutationInput!, where: UserWhereInput): AffectedRowsOutput!
  updateManyUserProvider(data: UserProviderUpdateManyMutationInput!, where: UserProviderWhereInput): AffectedRowsOutput!
  updateOneCategory(data: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category
  updateOneOffer(data: OfferUpdateInput!, where: OfferWhereUniqueInput!): Offer
  updateOneOrder(data: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order
  updateOneOrderItem(data: OrderItemUpdateInput!, where: OrderItemWhereUniqueInput!): OrderItem
  updateOneProduct(data: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product
  updateOneUser(data: UserUpdateInput!, where: UserWhereUniqueInput!): User
  updateOneUserProvider(data: UserProviderUpdateInput!, where: UserProviderWhereUniqueInput!): UserProvider
  upsertOneCategory(create: CategoryCreateInput!, update: CategoryUpdateInput!, where: CategoryWhereUniqueInput!): Category!
  upsertOneOffer(create: OfferCreateInput!, update: OfferUpdateInput!, where: OfferWhereUniqueInput!): Offer!
  upsertOneOrder(create: OrderCreateInput!, update: OrderUpdateInput!, where: OrderWhereUniqueInput!): Order!
  upsertOneOrderItem(create: OrderItemCreateInput!, update: OrderItemUpdateInput!, where: OrderItemWhereUniqueInput!): OrderItem!
  upsertOneProduct(create: ProductCreateInput!, update: ProductUpdateInput!, where: ProductWhereUniqueInput!): Product!
  upsertOneUser(create: UserCreateInput!, update: UserUpdateInput!, where: UserWhereUniqueInput!): User!
  upsertOneUserProvider(create: UserProviderCreateInput!, update: UserProviderUpdateInput!, where: UserProviderWhereUniqueInput!): UserProvider!
}

input NestedDateTimeFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableFilter {
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableFilter
  notIn: [DateTime!]
}

input NestedDateTimeNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedDateTimeNullableFilter
  _min: NestedDateTimeNullableFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeNullableWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedDateTimeWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedDateTimeFilter
  _min: NestedDateTimeFilter
  equals: DateTime
  gt: DateTime
  gte: DateTime
  in: [DateTime!]
  lt: DateTime
  lte: DateTime
  not: NestedDateTimeWithAggregatesFilter
  notIn: [DateTime!]
}

input NestedFloatFilter {
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatFilter
  notIn: [Float!]
}

input NestedFloatWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedFloatFilter
  _min: NestedFloatFilter
  _sum: NestedFloatFilter
  equals: Float
  gt: Float
  gte: Float
  in: [Float!]
  lt: Float
  lte: Float
  not: NestedFloatWithAggregatesFilter
  notIn: [Float!]
}

input NestedIntFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntFilter
  notIn: [Int!]
}

input NestedIntNullableFilter {
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntNullableFilter
  notIn: [Int!]
}

input NestedIntWithAggregatesFilter {
  _avg: NestedFloatFilter
  _count: NestedIntFilter
  _max: NestedIntFilter
  _min: NestedIntFilter
  _sum: NestedIntFilter
  equals: Int
  gt: Int
  gte: Int
  in: [Int!]
  lt: Int
  lte: Int
  not: NestedIntWithAggregatesFilter
  notIn: [Int!]
}

input NestedStringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NestedStringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input NullableDateTimeFieldUpdateOperationsInput {
  set: DateTime
}

input NullableStringFieldUpdateOperationsInput {
  set: String
}

type Offer {
  code: String
  discount: Float!
  endDate: DateTime
  id: String!
  product: Product!
  productId: String!
  startDate: DateTime
  type: String!
}

type OfferAvgAggregate {
  discount: Float
}

input OfferAvgOrderByAggregateInput {
  discount: SortOrder
}

type OfferCountAggregate {
  _all: Int!
  code: Int!
  discount: Int!
  endDate: Int!
  id: Int!
  productId: Int!
  startDate: Int!
  type: Int!
}

input OfferCountOrderByAggregateInput {
  code: SortOrder
  discount: SortOrder
  endDate: SortOrder
  id: SortOrder
  productId: SortOrder
  startDate: SortOrder
  type: SortOrder
}

input OfferCreateInput {
  code: String
  discount: Float!
  endDate: DateTime
  id: String
  product: ProductCreateNestedOneWithoutOffersInput!
  startDate: DateTime
  type: String!
}

input OfferCreateManyInput {
  code: String
  discount: Float!
  endDate: DateTime
  id: String
  productId: String!
  startDate: DateTime
  type: String!
}

input OfferCreateManyProductInput {
  code: String
  discount: Float!
  endDate: DateTime
  id: String
  startDate: DateTime
  type: String!
}

input OfferCreateManyProductInputEnvelope {
  data: [OfferCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input OfferCreateNestedManyWithoutProductInput {
  connect: [OfferWhereUniqueInput!]
  connectOrCreate: [OfferCreateOrConnectWithoutProductInput!]
  create: [OfferCreateWithoutProductInput!]
  createMany: OfferCreateManyProductInputEnvelope
}

input OfferCreateOrConnectWithoutProductInput {
  create: OfferCreateWithoutProductInput!
  where: OfferWhereUniqueInput!
}

input OfferCreateWithoutProductInput {
  code: String
  discount: Float!
  endDate: DateTime
  id: String
  startDate: DateTime
  type: String!
}

type OfferGroupBy {
  _avg: OfferAvgAggregate
  _count: OfferCountAggregate
  _max: OfferMaxAggregate
  _min: OfferMinAggregate
  _sum: OfferSumAggregate
  code: String
  discount: Float!
  endDate: DateTime
  id: String!
  productId: String!
  startDate: DateTime
  type: String!
}

input OfferListRelationFilter {
  every: OfferWhereInput
  none: OfferWhereInput
  some: OfferWhereInput
}

type OfferMaxAggregate {
  code: String
  discount: Float
  endDate: DateTime
  id: String
  productId: String
  startDate: DateTime
  type: String
}

input OfferMaxOrderByAggregateInput {
  code: SortOrder
  discount: SortOrder
  endDate: SortOrder
  id: SortOrder
  productId: SortOrder
  startDate: SortOrder
  type: SortOrder
}

type OfferMinAggregate {
  code: String
  discount: Float
  endDate: DateTime
  id: String
  productId: String
  startDate: DateTime
  type: String
}

input OfferMinOrderByAggregateInput {
  code: SortOrder
  discount: SortOrder
  endDate: SortOrder
  id: SortOrder
  productId: SortOrder
  startDate: SortOrder
  type: SortOrder
}

input OfferOrderByRelationAggregateInput {
  _count: SortOrder
}

input OfferOrderByWithAggregationInput {
  _avg: OfferAvgOrderByAggregateInput
  _count: OfferCountOrderByAggregateInput
  _max: OfferMaxOrderByAggregateInput
  _min: OfferMinOrderByAggregateInput
  _sum: OfferSumOrderByAggregateInput
  code: SortOrder
  discount: SortOrder
  endDate: SortOrder
  id: SortOrder
  productId: SortOrder
  startDate: SortOrder
  type: SortOrder
}

input OfferOrderByWithRelationInput {
  code: SortOrder
  discount: SortOrder
  endDate: SortOrder
  id: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  startDate: SortOrder
  type: SortOrder
}

enum OfferScalarFieldEnum {
  code
  discount
  endDate
  id
  productId
  startDate
  type
}

input OfferScalarWhereInput {
  AND: [OfferScalarWhereInput!]
  NOT: [OfferScalarWhereInput!]
  OR: [OfferScalarWhereInput!]
  code: StringNullableFilter
  discount: FloatFilter
  endDate: DateTimeNullableFilter
  id: StringFilter
  productId: StringFilter
  startDate: DateTimeNullableFilter
  type: StringFilter
}

input OfferScalarWhereWithAggregatesInput {
  AND: [OfferScalarWhereWithAggregatesInput!]
  NOT: [OfferScalarWhereWithAggregatesInput!]
  OR: [OfferScalarWhereWithAggregatesInput!]
  code: StringNullableWithAggregatesFilter
  discount: FloatWithAggregatesFilter
  endDate: DateTimeNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  productId: StringWithAggregatesFilter
  startDate: DateTimeNullableWithAggregatesFilter
  type: StringWithAggregatesFilter
}

type OfferSumAggregate {
  discount: Float
}

input OfferSumOrderByAggregateInput {
  discount: SortOrder
}

input OfferUpdateInput {
  code: NullableStringFieldUpdateOperationsInput
  discount: FloatFieldUpdateOperationsInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOffersNestedInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input OfferUpdateManyMutationInput {
  code: NullableStringFieldUpdateOperationsInput
  discount: FloatFieldUpdateOperationsInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input OfferUpdateManyWithWhereWithoutProductInput {
  data: OfferUpdateManyMutationInput!
  where: OfferScalarWhereInput!
}

input OfferUpdateManyWithoutProductNestedInput {
  connect: [OfferWhereUniqueInput!]
  connectOrCreate: [OfferCreateOrConnectWithoutProductInput!]
  create: [OfferCreateWithoutProductInput!]
  createMany: OfferCreateManyProductInputEnvelope
  delete: [OfferWhereUniqueInput!]
  deleteMany: [OfferScalarWhereInput!]
  disconnect: [OfferWhereUniqueInput!]
  set: [OfferWhereUniqueInput!]
  update: [OfferUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [OfferUpdateManyWithWhereWithoutProductInput!]
  upsert: [OfferUpsertWithWhereUniqueWithoutProductInput!]
}

input OfferUpdateWithWhereUniqueWithoutProductInput {
  data: OfferUpdateWithoutProductInput!
  where: OfferWhereUniqueInput!
}

input OfferUpdateWithoutProductInput {
  code: NullableStringFieldUpdateOperationsInput
  discount: FloatFieldUpdateOperationsInput
  endDate: NullableDateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  startDate: NullableDateTimeFieldUpdateOperationsInput
  type: StringFieldUpdateOperationsInput
}

input OfferUpsertWithWhereUniqueWithoutProductInput {
  create: OfferCreateWithoutProductInput!
  update: OfferUpdateWithoutProductInput!
  where: OfferWhereUniqueInput!
}

input OfferWhereInput {
  AND: [OfferWhereInput!]
  NOT: [OfferWhereInput!]
  OR: [OfferWhereInput!]
  code: StringNullableFilter
  discount: FloatFilter
  endDate: DateTimeNullableFilter
  id: StringFilter
  product: ProductRelationFilter
  productId: StringFilter
  startDate: DateTimeNullableFilter
  type: StringFilter
}

input OfferWhereUniqueInput {
  id: String
}

type Order {
  _count: OrderCount
  createdAt: DateTime!
  id: String!
  items(cursor: OrderItemWhereUniqueInput, distinct: [OrderItemScalarFieldEnum!], orderBy: [OrderItemOrderByWithRelationInput!], skip: Int, take: Int, where: OrderItemWhereInput): [OrderItem!]!
  total: Float!
  user: User!
  userId: String!
}

type OrderAvgAggregate {
  total: Float
}

input OrderAvgOrderByAggregateInput {
  total: SortOrder
}

type OrderCount {
  items: Int!
}

type OrderCountAggregate {
  _all: Int!
  createdAt: Int!
  id: Int!
  total: Int!
  userId: Int!
}

input OrderCountOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  total: SortOrder
  userId: SortOrder
}

input OrderCreateInput {
  createdAt: DateTime
  id: String
  items: OrderItemCreateNestedManyWithoutOrderInput
  total: Float!
  user: UserCreateNestedOneWithoutOrdersInput!
}

input OrderCreateManyInput {
  createdAt: DateTime
  id: String
  total: Float!
  userId: String!
}

input OrderCreateManyUserInput {
  createdAt: DateTime
  id: String
  total: Float!
}

input OrderCreateManyUserInputEnvelope {
  data: [OrderCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input OrderCreateNestedManyWithoutUserInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutUserInput!]
  create: [OrderCreateWithoutUserInput!]
  createMany: OrderCreateManyUserInputEnvelope
}

input OrderCreateNestedOneWithoutItemsInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutItemsInput
  create: OrderCreateWithoutItemsInput
}

input OrderCreateOrConnectWithoutItemsInput {
  create: OrderCreateWithoutItemsInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateOrConnectWithoutUserInput {
  create: OrderCreateWithoutUserInput!
  where: OrderWhereUniqueInput!
}

input OrderCreateWithoutItemsInput {
  createdAt: DateTime
  id: String
  total: Float!
  user: UserCreateNestedOneWithoutOrdersInput!
}

input OrderCreateWithoutUserInput {
  createdAt: DateTime
  id: String
  items: OrderItemCreateNestedManyWithoutOrderInput
  total: Float!
}

type OrderGroupBy {
  _avg: OrderAvgAggregate
  _count: OrderCountAggregate
  _max: OrderMaxAggregate
  _min: OrderMinAggregate
  _sum: OrderSumAggregate
  createdAt: DateTime!
  id: String!
  total: Float!
  userId: String!
}

type OrderItem {
  id: String!
  order: Order!
  orderId: String!
  price: Float!
  product: Product!
  productId: String!
  quantity: Int!
}

type OrderItemAvgAggregate {
  price: Float
  quantity: Float
}

input OrderItemAvgOrderByAggregateInput {
  price: SortOrder
  quantity: SortOrder
}

type OrderItemCountAggregate {
  _all: Int!
  id: Int!
  orderId: Int!
  price: Int!
  productId: Int!
  quantity: Int!
}

input OrderItemCountOrderByAggregateInput {
  id: SortOrder
  orderId: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
}

input OrderItemCreateInput {
  id: String
  order: OrderCreateNestedOneWithoutItemsInput!
  price: Float!
  product: ProductCreateNestedOneWithoutOrdersInput!
  quantity: Int!
}

input OrderItemCreateManyInput {
  id: String
  orderId: String!
  price: Float!
  productId: String!
  quantity: Int!
}

input OrderItemCreateManyOrderInput {
  id: String
  price: Float!
  productId: String!
  quantity: Int!
}

input OrderItemCreateManyOrderInputEnvelope {
  data: [OrderItemCreateManyOrderInput!]!
  skipDuplicates: Boolean
}

input OrderItemCreateManyProductInput {
  id: String
  orderId: String!
  price: Float!
  quantity: Int!
}

input OrderItemCreateManyProductInputEnvelope {
  data: [OrderItemCreateManyProductInput!]!
  skipDuplicates: Boolean
}

input OrderItemCreateNestedManyWithoutOrderInput {
  connect: [OrderItemWhereUniqueInput!]
  connectOrCreate: [OrderItemCreateOrConnectWithoutOrderInput!]
  create: [OrderItemCreateWithoutOrderInput!]
  createMany: OrderItemCreateManyOrderInputEnvelope
}

input OrderItemCreateNestedManyWithoutProductInput {
  connect: [OrderItemWhereUniqueInput!]
  connectOrCreate: [OrderItemCreateOrConnectWithoutProductInput!]
  create: [OrderItemCreateWithoutProductInput!]
  createMany: OrderItemCreateManyProductInputEnvelope
}

input OrderItemCreateOrConnectWithoutOrderInput {
  create: OrderItemCreateWithoutOrderInput!
  where: OrderItemWhereUniqueInput!
}

input OrderItemCreateOrConnectWithoutProductInput {
  create: OrderItemCreateWithoutProductInput!
  where: OrderItemWhereUniqueInput!
}

input OrderItemCreateWithoutOrderInput {
  id: String
  price: Float!
  product: ProductCreateNestedOneWithoutOrdersInput!
  quantity: Int!
}

input OrderItemCreateWithoutProductInput {
  id: String
  order: OrderCreateNestedOneWithoutItemsInput!
  price: Float!
  quantity: Int!
}

type OrderItemGroupBy {
  _avg: OrderItemAvgAggregate
  _count: OrderItemCountAggregate
  _max: OrderItemMaxAggregate
  _min: OrderItemMinAggregate
  _sum: OrderItemSumAggregate
  id: String!
  orderId: String!
  price: Float!
  productId: String!
  quantity: Int!
}

input OrderItemListRelationFilter {
  every: OrderItemWhereInput
  none: OrderItemWhereInput
  some: OrderItemWhereInput
}

type OrderItemMaxAggregate {
  id: String
  orderId: String
  price: Float
  productId: String
  quantity: Int
}

input OrderItemMaxOrderByAggregateInput {
  id: SortOrder
  orderId: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
}

type OrderItemMinAggregate {
  id: String
  orderId: String
  price: Float
  productId: String
  quantity: Int
}

input OrderItemMinOrderByAggregateInput {
  id: SortOrder
  orderId: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
}

input OrderItemOrderByRelationAggregateInput {
  _count: SortOrder
}

input OrderItemOrderByWithAggregationInput {
  _avg: OrderItemAvgOrderByAggregateInput
  _count: OrderItemCountOrderByAggregateInput
  _max: OrderItemMaxOrderByAggregateInput
  _min: OrderItemMinOrderByAggregateInput
  _sum: OrderItemSumOrderByAggregateInput
  id: SortOrder
  orderId: SortOrder
  price: SortOrder
  productId: SortOrder
  quantity: SortOrder
}

input OrderItemOrderByWithRelationInput {
  id: SortOrder
  order: OrderOrderByWithRelationInput
  orderId: SortOrder
  price: SortOrder
  product: ProductOrderByWithRelationInput
  productId: SortOrder
  quantity: SortOrder
}

enum OrderItemScalarFieldEnum {
  id
  orderId
  price
  productId
  quantity
}

input OrderItemScalarWhereInput {
  AND: [OrderItemScalarWhereInput!]
  NOT: [OrderItemScalarWhereInput!]
  OR: [OrderItemScalarWhereInput!]
  id: StringFilter
  orderId: StringFilter
  price: FloatFilter
  productId: StringFilter
  quantity: IntFilter
}

input OrderItemScalarWhereWithAggregatesInput {
  AND: [OrderItemScalarWhereWithAggregatesInput!]
  NOT: [OrderItemScalarWhereWithAggregatesInput!]
  OR: [OrderItemScalarWhereWithAggregatesInput!]
  id: StringWithAggregatesFilter
  orderId: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
  productId: StringWithAggregatesFilter
  quantity: IntWithAggregatesFilter
}

type OrderItemSumAggregate {
  price: Float
  quantity: Int
}

input OrderItemSumOrderByAggregateInput {
  price: SortOrder
  quantity: SortOrder
}

input OrderItemUpdateInput {
  id: StringFieldUpdateOperationsInput
  order: OrderUpdateOneRequiredWithoutItemsNestedInput
  price: FloatFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOrdersNestedInput
  quantity: IntFieldUpdateOperationsInput
}

input OrderItemUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
}

input OrderItemUpdateManyWithWhereWithoutOrderInput {
  data: OrderItemUpdateManyMutationInput!
  where: OrderItemScalarWhereInput!
}

input OrderItemUpdateManyWithWhereWithoutProductInput {
  data: OrderItemUpdateManyMutationInput!
  where: OrderItemScalarWhereInput!
}

input OrderItemUpdateManyWithoutOrderNestedInput {
  connect: [OrderItemWhereUniqueInput!]
  connectOrCreate: [OrderItemCreateOrConnectWithoutOrderInput!]
  create: [OrderItemCreateWithoutOrderInput!]
  createMany: OrderItemCreateManyOrderInputEnvelope
  delete: [OrderItemWhereUniqueInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  update: [OrderItemUpdateWithWhereUniqueWithoutOrderInput!]
  updateMany: [OrderItemUpdateManyWithWhereWithoutOrderInput!]
  upsert: [OrderItemUpsertWithWhereUniqueWithoutOrderInput!]
}

input OrderItemUpdateManyWithoutProductNestedInput {
  connect: [OrderItemWhereUniqueInput!]
  connectOrCreate: [OrderItemCreateOrConnectWithoutProductInput!]
  create: [OrderItemCreateWithoutProductInput!]
  createMany: OrderItemCreateManyProductInputEnvelope
  delete: [OrderItemWhereUniqueInput!]
  deleteMany: [OrderItemScalarWhereInput!]
  disconnect: [OrderItemWhereUniqueInput!]
  set: [OrderItemWhereUniqueInput!]
  update: [OrderItemUpdateWithWhereUniqueWithoutProductInput!]
  updateMany: [OrderItemUpdateManyWithWhereWithoutProductInput!]
  upsert: [OrderItemUpsertWithWhereUniqueWithoutProductInput!]
}

input OrderItemUpdateWithWhereUniqueWithoutOrderInput {
  data: OrderItemUpdateWithoutOrderInput!
  where: OrderItemWhereUniqueInput!
}

input OrderItemUpdateWithWhereUniqueWithoutProductInput {
  data: OrderItemUpdateWithoutProductInput!
  where: OrderItemWhereUniqueInput!
}

input OrderItemUpdateWithoutOrderInput {
  id: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  product: ProductUpdateOneRequiredWithoutOrdersNestedInput
  quantity: IntFieldUpdateOperationsInput
}

input OrderItemUpdateWithoutProductInput {
  id: StringFieldUpdateOperationsInput
  order: OrderUpdateOneRequiredWithoutItemsNestedInput
  price: FloatFieldUpdateOperationsInput
  quantity: IntFieldUpdateOperationsInput
}

input OrderItemUpsertWithWhereUniqueWithoutOrderInput {
  create: OrderItemCreateWithoutOrderInput!
  update: OrderItemUpdateWithoutOrderInput!
  where: OrderItemWhereUniqueInput!
}

input OrderItemUpsertWithWhereUniqueWithoutProductInput {
  create: OrderItemCreateWithoutProductInput!
  update: OrderItemUpdateWithoutProductInput!
  where: OrderItemWhereUniqueInput!
}

input OrderItemWhereInput {
  AND: [OrderItemWhereInput!]
  NOT: [OrderItemWhereInput!]
  OR: [OrderItemWhereInput!]
  id: StringFilter
  order: OrderRelationFilter
  orderId: StringFilter
  price: FloatFilter
  product: ProductRelationFilter
  productId: StringFilter
  quantity: IntFilter
}

input OrderItemWhereUniqueInput {
  id: String
}

input OrderListRelationFilter {
  every: OrderWhereInput
  none: OrderWhereInput
  some: OrderWhereInput
}

type OrderMaxAggregate {
  createdAt: DateTime
  id: String
  total: Float
  userId: String
}

input OrderMaxOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  total: SortOrder
  userId: SortOrder
}

type OrderMinAggregate {
  createdAt: DateTime
  id: String
  total: Float
  userId: String
}

input OrderMinOrderByAggregateInput {
  createdAt: SortOrder
  id: SortOrder
  total: SortOrder
  userId: SortOrder
}

input OrderOrderByRelationAggregateInput {
  _count: SortOrder
}

input OrderOrderByWithAggregationInput {
  _avg: OrderAvgOrderByAggregateInput
  _count: OrderCountOrderByAggregateInput
  _max: OrderMaxOrderByAggregateInput
  _min: OrderMinOrderByAggregateInput
  _sum: OrderSumOrderByAggregateInput
  createdAt: SortOrder
  id: SortOrder
  total: SortOrder
  userId: SortOrder
}

input OrderOrderByWithRelationInput {
  createdAt: SortOrder
  id: SortOrder
  items: OrderItemOrderByRelationAggregateInput
  total: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

input OrderRelationFilter {
  is: OrderWhereInput
  isNot: OrderWhereInput
}

enum OrderScalarFieldEnum {
  createdAt
  id
  total
  userId
}

input OrderScalarWhereInput {
  AND: [OrderScalarWhereInput!]
  NOT: [OrderScalarWhereInput!]
  OR: [OrderScalarWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  total: FloatFilter
  userId: StringFilter
}

input OrderScalarWhereWithAggregatesInput {
  AND: [OrderScalarWhereWithAggregatesInput!]
  NOT: [OrderScalarWhereWithAggregatesInput!]
  OR: [OrderScalarWhereWithAggregatesInput!]
  createdAt: DateTimeWithAggregatesFilter
  id: StringWithAggregatesFilter
  total: FloatWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

type OrderSumAggregate {
  total: Float
}

input OrderSumOrderByAggregateInput {
  total: SortOrder
}

input OrderUpdateInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  items: OrderItemUpdateManyWithoutOrderNestedInput
  total: FloatFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutOrdersNestedInput
}

input OrderUpdateManyMutationInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  total: FloatFieldUpdateOperationsInput
}

input OrderUpdateManyWithWhereWithoutUserInput {
  data: OrderUpdateManyMutationInput!
  where: OrderScalarWhereInput!
}

input OrderUpdateManyWithoutUserNestedInput {
  connect: [OrderWhereUniqueInput!]
  connectOrCreate: [OrderCreateOrConnectWithoutUserInput!]
  create: [OrderCreateWithoutUserInput!]
  createMany: OrderCreateManyUserInputEnvelope
  delete: [OrderWhereUniqueInput!]
  deleteMany: [OrderScalarWhereInput!]
  disconnect: [OrderWhereUniqueInput!]
  set: [OrderWhereUniqueInput!]
  update: [OrderUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [OrderUpdateManyWithWhereWithoutUserInput!]
  upsert: [OrderUpsertWithWhereUniqueWithoutUserInput!]
}

input OrderUpdateOneRequiredWithoutItemsNestedInput {
  connect: OrderWhereUniqueInput
  connectOrCreate: OrderCreateOrConnectWithoutItemsInput
  create: OrderCreateWithoutItemsInput
  update: OrderUpdateWithoutItemsInput
  upsert: OrderUpsertWithoutItemsInput
}

input OrderUpdateWithWhereUniqueWithoutUserInput {
  data: OrderUpdateWithoutUserInput!
  where: OrderWhereUniqueInput!
}

input OrderUpdateWithoutItemsInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  total: FloatFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutOrdersNestedInput
}

input OrderUpdateWithoutUserInput {
  createdAt: DateTimeFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  items: OrderItemUpdateManyWithoutOrderNestedInput
  total: FloatFieldUpdateOperationsInput
}

input OrderUpsertWithWhereUniqueWithoutUserInput {
  create: OrderCreateWithoutUserInput!
  update: OrderUpdateWithoutUserInput!
  where: OrderWhereUniqueInput!
}

input OrderUpsertWithoutItemsInput {
  create: OrderCreateWithoutItemsInput!
  update: OrderUpdateWithoutItemsInput!
}

input OrderWhereInput {
  AND: [OrderWhereInput!]
  NOT: [OrderWhereInput!]
  OR: [OrderWhereInput!]
  createdAt: DateTimeFilter
  id: StringFilter
  items: OrderItemListRelationFilter
  total: FloatFilter
  user: UserRelationFilter
  userId: StringFilter
}

input OrderWhereUniqueInput {
  id: String
}

type Product {
  _count: ProductCount
  category: Category!
  categoryId: String!
  id: String!
  image: String!
  name: String!
  offers(cursor: OfferWhereUniqueInput, distinct: [OfferScalarFieldEnum!], orderBy: [OfferOrderByWithRelationInput!], skip: Int, take: Int, where: OfferWhereInput): [Offer!]!
  orders(cursor: OrderItemWhereUniqueInput, distinct: [OrderItemScalarFieldEnum!], orderBy: [OrderItemOrderByWithRelationInput!], skip: Int, take: Int, where: OrderItemWhereInput): [OrderItem!]!
  price: Float!
  sku: String!
  stock: Int!
}

type ProductAvgAggregate {
  price: Float
  stock: Float
}

input ProductAvgOrderByAggregateInput {
  price: SortOrder
  stock: SortOrder
}

type ProductCount {
  offers: Int!
  orders: Int!
}

type ProductCountAggregate {
  _all: Int!
  categoryId: Int!
  id: Int!
  image: Int!
  name: Int!
  price: Int!
  sku: Int!
  stock: Int!
}

input ProductCountOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  price: SortOrder
  sku: SortOrder
  stock: SortOrder
}

input ProductCreateInput {
  category: CategoryCreateNestedOneWithoutProductsInput!
  id: String
  image: String!
  name: String!
  offers: OfferCreateNestedManyWithoutProductInput
  orders: OrderItemCreateNestedManyWithoutProductInput
  price: Float!
  sku: String!
  stock: Int!
}

input ProductCreateManyCategoryInput {
  id: String
  image: String!
  name: String!
  price: Float!
  sku: String!
  stock: Int!
}

input ProductCreateManyCategoryInputEnvelope {
  data: [ProductCreateManyCategoryInput!]!
  skipDuplicates: Boolean
}

input ProductCreateManyInput {
  categoryId: String!
  id: String
  image: String!
  name: String!
  price: Float!
  sku: String!
  stock: Int!
}

input ProductCreateNestedManyWithoutCategoryInput {
  connect: [ProductWhereUniqueInput!]
  connectOrCreate: [ProductCreateOrConnectWithoutCategoryInput!]
  create: [ProductCreateWithoutCategoryInput!]
  createMany: ProductCreateManyCategoryInputEnvelope
}

input ProductCreateNestedOneWithoutOffersInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOffersInput
  create: ProductCreateWithoutOffersInput
}

input ProductCreateNestedOneWithoutOrdersInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOrdersInput
  create: ProductCreateWithoutOrdersInput
}

input ProductCreateOrConnectWithoutCategoryInput {
  create: ProductCreateWithoutCategoryInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutOffersInput {
  create: ProductCreateWithoutOffersInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateOrConnectWithoutOrdersInput {
  create: ProductCreateWithoutOrdersInput!
  where: ProductWhereUniqueInput!
}

input ProductCreateWithoutCategoryInput {
  id: String
  image: String!
  name: String!
  offers: OfferCreateNestedManyWithoutProductInput
  orders: OrderItemCreateNestedManyWithoutProductInput
  price: Float!
  sku: String!
  stock: Int!
}

input ProductCreateWithoutOffersInput {
  category: CategoryCreateNestedOneWithoutProductsInput!
  id: String
  image: String!
  name: String!
  orders: OrderItemCreateNestedManyWithoutProductInput
  price: Float!
  sku: String!
  stock: Int!
}

input ProductCreateWithoutOrdersInput {
  category: CategoryCreateNestedOneWithoutProductsInput!
  id: String
  image: String!
  name: String!
  offers: OfferCreateNestedManyWithoutProductInput
  price: Float!
  sku: String!
  stock: Int!
}

type ProductGroupBy {
  _avg: ProductAvgAggregate
  _count: ProductCountAggregate
  _max: ProductMaxAggregate
  _min: ProductMinAggregate
  _sum: ProductSumAggregate
  categoryId: String!
  id: String!
  image: String!
  name: String!
  price: Float!
  sku: String!
  stock: Int!
}

input ProductListRelationFilter {
  every: ProductWhereInput
  none: ProductWhereInput
  some: ProductWhereInput
}

type ProductMaxAggregate {
  categoryId: String
  id: String
  image: String
  name: String
  price: Float
  sku: String
  stock: Int
}

input ProductMaxOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  price: SortOrder
  sku: SortOrder
  stock: SortOrder
}

type ProductMinAggregate {
  categoryId: String
  id: String
  image: String
  name: String
  price: Float
  sku: String
  stock: Int
}

input ProductMinOrderByAggregateInput {
  categoryId: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  price: SortOrder
  sku: SortOrder
  stock: SortOrder
}

input ProductOrderByRelationAggregateInput {
  _count: SortOrder
}

input ProductOrderByWithAggregationInput {
  _avg: ProductAvgOrderByAggregateInput
  _count: ProductCountOrderByAggregateInput
  _max: ProductMaxOrderByAggregateInput
  _min: ProductMinOrderByAggregateInput
  _sum: ProductSumOrderByAggregateInput
  categoryId: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  price: SortOrder
  sku: SortOrder
  stock: SortOrder
}

input ProductOrderByWithRelationInput {
  category: CategoryOrderByWithRelationInput
  categoryId: SortOrder
  id: SortOrder
  image: SortOrder
  name: SortOrder
  offers: OfferOrderByRelationAggregateInput
  orders: OrderItemOrderByRelationAggregateInput
  price: SortOrder
  sku: SortOrder
  stock: SortOrder
}

input ProductRelationFilter {
  is: ProductWhereInput
  isNot: ProductWhereInput
}

enum ProductScalarFieldEnum {
  categoryId
  id
  image
  name
  price
  sku
  stock
}

input ProductScalarWhereInput {
  AND: [ProductScalarWhereInput!]
  NOT: [ProductScalarWhereInput!]
  OR: [ProductScalarWhereInput!]
  categoryId: StringFilter
  id: StringFilter
  image: StringFilter
  name: StringFilter
  price: FloatFilter
  sku: StringFilter
  stock: IntFilter
}

input ProductScalarWhereWithAggregatesInput {
  AND: [ProductScalarWhereWithAggregatesInput!]
  NOT: [ProductScalarWhereWithAggregatesInput!]
  OR: [ProductScalarWhereWithAggregatesInput!]
  categoryId: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  image: StringWithAggregatesFilter
  name: StringWithAggregatesFilter
  price: FloatWithAggregatesFilter
  sku: StringWithAggregatesFilter
  stock: IntWithAggregatesFilter
}

type ProductSumAggregate {
  price: Float
  stock: Int
}

input ProductSumOrderByAggregateInput {
  price: SortOrder
  stock: SortOrder
}

input ProductUpdateInput {
  category: CategoryUpdateOneRequiredWithoutProductsNestedInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offers: OfferUpdateManyWithoutProductNestedInput
  orders: OrderItemUpdateManyWithoutProductNestedInput
  price: FloatFieldUpdateOperationsInput
  sku: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
}

input ProductUpdateManyMutationInput {
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  price: FloatFieldUpdateOperationsInput
  sku: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
}

input ProductUpdateManyWithWhereWithoutCategoryInput {
  data: ProductUpdateManyMutationInput!
  where: ProductScalarWhereInput!
}

input ProductUpdateManyWithoutCategoryNestedInput {
  connect: [ProductWhereUniqueInput!]
  connectOrCreate: [ProductCreateOrConnectWithoutCategoryInput!]
  create: [ProductCreateWithoutCategoryInput!]
  createMany: ProductCreateManyCategoryInputEnvelope
  delete: [ProductWhereUniqueInput!]
  deleteMany: [ProductScalarWhereInput!]
  disconnect: [ProductWhereUniqueInput!]
  set: [ProductWhereUniqueInput!]
  update: [ProductUpdateWithWhereUniqueWithoutCategoryInput!]
  updateMany: [ProductUpdateManyWithWhereWithoutCategoryInput!]
  upsert: [ProductUpsertWithWhereUniqueWithoutCategoryInput!]
}

input ProductUpdateOneRequiredWithoutOffersNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOffersInput
  create: ProductCreateWithoutOffersInput
  update: ProductUpdateWithoutOffersInput
  upsert: ProductUpsertWithoutOffersInput
}

input ProductUpdateOneRequiredWithoutOrdersNestedInput {
  connect: ProductWhereUniqueInput
  connectOrCreate: ProductCreateOrConnectWithoutOrdersInput
  create: ProductCreateWithoutOrdersInput
  update: ProductUpdateWithoutOrdersInput
  upsert: ProductUpsertWithoutOrdersInput
}

input ProductUpdateWithWhereUniqueWithoutCategoryInput {
  data: ProductUpdateWithoutCategoryInput!
  where: ProductWhereUniqueInput!
}

input ProductUpdateWithoutCategoryInput {
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offers: OfferUpdateManyWithoutProductNestedInput
  orders: OrderItemUpdateManyWithoutProductNestedInput
  price: FloatFieldUpdateOperationsInput
  sku: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
}

input ProductUpdateWithoutOffersInput {
  category: CategoryUpdateOneRequiredWithoutProductsNestedInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  orders: OrderItemUpdateManyWithoutProductNestedInput
  price: FloatFieldUpdateOperationsInput
  sku: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
}

input ProductUpdateWithoutOrdersInput {
  category: CategoryUpdateOneRequiredWithoutProductsNestedInput
  id: StringFieldUpdateOperationsInput
  image: StringFieldUpdateOperationsInput
  name: StringFieldUpdateOperationsInput
  offers: OfferUpdateManyWithoutProductNestedInput
  price: FloatFieldUpdateOperationsInput
  sku: StringFieldUpdateOperationsInput
  stock: IntFieldUpdateOperationsInput
}

input ProductUpsertWithWhereUniqueWithoutCategoryInput {
  create: ProductCreateWithoutCategoryInput!
  update: ProductUpdateWithoutCategoryInput!
  where: ProductWhereUniqueInput!
}

input ProductUpsertWithoutOffersInput {
  create: ProductCreateWithoutOffersInput!
  update: ProductUpdateWithoutOffersInput!
}

input ProductUpsertWithoutOrdersInput {
  create: ProductCreateWithoutOrdersInput!
  update: ProductUpdateWithoutOrdersInput!
}

input ProductWhereInput {
  AND: [ProductWhereInput!]
  NOT: [ProductWhereInput!]
  OR: [ProductWhereInput!]
  category: CategoryRelationFilter
  categoryId: StringFilter
  id: StringFilter
  image: StringFilter
  name: StringFilter
  offers: OfferListRelationFilter
  orders: OrderItemListRelationFilter
  price: FloatFilter
  sku: StringFilter
  stock: IntFilter
}

input ProductWhereUniqueInput {
  id: String
  sku: String
}

type Query {
  aggregateCategory(cursor: CategoryWhereUniqueInput, orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): AggregateCategory!
  aggregateOffer(cursor: OfferWhereUniqueInput, orderBy: [OfferOrderByWithRelationInput!], skip: Int, take: Int, where: OfferWhereInput): AggregateOffer!
  aggregateOrder(cursor: OrderWhereUniqueInput, orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): AggregateOrder!
  aggregateOrderItem(cursor: OrderItemWhereUniqueInput, orderBy: [OrderItemOrderByWithRelationInput!], skip: Int, take: Int, where: OrderItemWhereInput): AggregateOrderItem!
  aggregateProduct(cursor: ProductWhereUniqueInput, orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): AggregateProduct!
  aggregateUser(cursor: UserWhereUniqueInput, orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): AggregateUser!
  aggregateUserProvider(cursor: UserProviderWhereUniqueInput, orderBy: [UserProviderOrderByWithRelationInput!], skip: Int, take: Int, where: UserProviderWhereInput): AggregateUserProvider!
  allCategories: [Category]
  allProducts: [Product]
  allUsers: [User]
  categories(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): [Category!]!
  category(where: CategoryWhereUniqueInput!): Category
  categoryById(id: String): Category
  findFirstCategory(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstCategoryOrThrow(cursor: CategoryWhereUniqueInput, distinct: [CategoryScalarFieldEnum!], orderBy: [CategoryOrderByWithRelationInput!], skip: Int, take: Int, where: CategoryWhereInput): Category
  findFirstOffer(cursor: OfferWhereUniqueInput, distinct: [OfferScalarFieldEnum!], orderBy: [OfferOrderByWithRelationInput!], skip: Int, take: Int, where: OfferWhereInput): Offer
  findFirstOfferOrThrow(cursor: OfferWhereUniqueInput, distinct: [OfferScalarFieldEnum!], orderBy: [OfferOrderByWithRelationInput!], skip: Int, take: Int, where: OfferWhereInput): Offer
  findFirstOrder(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): Order
  findFirstOrderItem(cursor: OrderItemWhereUniqueInput, distinct: [OrderItemScalarFieldEnum!], orderBy: [OrderItemOrderByWithRelationInput!], skip: Int, take: Int, where: OrderItemWhereInput): OrderItem
  findFirstOrderItemOrThrow(cursor: OrderItemWhereUniqueInput, distinct: [OrderItemScalarFieldEnum!], orderBy: [OrderItemOrderByWithRelationInput!], skip: Int, take: Int, where: OrderItemWhereInput): OrderItem
  findFirstOrderOrThrow(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): Order
  findFirstProduct(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstProductOrThrow(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): Product
  findFirstUser(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserOrThrow(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): User
  findFirstUserProvider(cursor: UserProviderWhereUniqueInput, distinct: [UserProviderScalarFieldEnum!], orderBy: [UserProviderOrderByWithRelationInput!], skip: Int, take: Int, where: UserProviderWhereInput): UserProvider
  findFirstUserProviderOrThrow(cursor: UserProviderWhereUniqueInput, distinct: [UserProviderScalarFieldEnum!], orderBy: [UserProviderOrderByWithRelationInput!], skip: Int, take: Int, where: UserProviderWhereInput): UserProvider
  getCategory(where: CategoryWhereUniqueInput!): Category
  getOffer(where: OfferWhereUniqueInput!): Offer
  getOrder(where: OrderWhereUniqueInput!): Order
  getOrderItem(where: OrderItemWhereUniqueInput!): OrderItem
  getProduct(where: ProductWhereUniqueInput!): Product
  getUser(where: UserWhereUniqueInput!): User
  getUserProvider(where: UserProviderWhereUniqueInput!): UserProvider
  groupByCategory(by: [CategoryScalarFieldEnum!]!, having: CategoryScalarWhereWithAggregatesInput, orderBy: [CategoryOrderByWithAggregationInput!], skip: Int, take: Int, where: CategoryWhereInput): [CategoryGroupBy!]!
  groupByOffer(by: [OfferScalarFieldEnum!]!, having: OfferScalarWhereWithAggregatesInput, orderBy: [OfferOrderByWithAggregationInput!], skip: Int, take: Int, where: OfferWhereInput): [OfferGroupBy!]!
  groupByOrder(by: [OrderScalarFieldEnum!]!, having: OrderScalarWhereWithAggregatesInput, orderBy: [OrderOrderByWithAggregationInput!], skip: Int, take: Int, where: OrderWhereInput): [OrderGroupBy!]!
  groupByOrderItem(by: [OrderItemScalarFieldEnum!]!, having: OrderItemScalarWhereWithAggregatesInput, orderBy: [OrderItemOrderByWithAggregationInput!], skip: Int, take: Int, where: OrderItemWhereInput): [OrderItemGroupBy!]!
  groupByProduct(by: [ProductScalarFieldEnum!]!, having: ProductScalarWhereWithAggregatesInput, orderBy: [ProductOrderByWithAggregationInput!], skip: Int, take: Int, where: ProductWhereInput): [ProductGroupBy!]!
  groupByUser(by: [UserScalarFieldEnum!]!, having: UserScalarWhereWithAggregatesInput, orderBy: [UserOrderByWithAggregationInput!], skip: Int, take: Int, where: UserWhereInput): [UserGroupBy!]!
  groupByUserProvider(by: [UserProviderScalarFieldEnum!]!, having: UserProviderScalarWhereWithAggregatesInput, orderBy: [UserProviderOrderByWithAggregationInput!], skip: Int, take: Int, where: UserProviderWhereInput): [UserProviderGroupBy!]!
  offer(where: OfferWhereUniqueInput!): Offer
  offers(cursor: OfferWhereUniqueInput, distinct: [OfferScalarFieldEnum!], orderBy: [OfferOrderByWithRelationInput!], skip: Int, take: Int, where: OfferWhereInput): [Offer!]!
  order(where: OrderWhereUniqueInput!): Order
  orderItem(where: OrderItemWhereUniqueInput!): OrderItem
  orderItems(cursor: OrderItemWhereUniqueInput, distinct: [OrderItemScalarFieldEnum!], orderBy: [OrderItemOrderByWithRelationInput!], skip: Int, take: Int, where: OrderItemWhereInput): [OrderItem!]!
  orders(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  product(where: ProductWhereUniqueInput!): Product
  productById(id: String): Product
  products(cursor: ProductWhereUniqueInput, distinct: [ProductScalarFieldEnum!], orderBy: [ProductOrderByWithRelationInput!], skip: Int, take: Int, where: ProductWhereInput): [Product!]!
  user(where: UserWhereUniqueInput!): User
  userById: User
  userProvider(where: UserProviderWhereUniqueInput!): UserProvider
  userProviders(cursor: UserProviderWhereUniqueInput, distinct: [UserProviderScalarFieldEnum!], orderBy: [UserProviderOrderByWithRelationInput!], skip: Int, take: Int, where: UserProviderWhereInput): [UserProvider!]!
  users(cursor: UserWhereUniqueInput, distinct: [UserScalarFieldEnum!], orderBy: [UserOrderByWithRelationInput!], skip: Int, take: Int, where: UserWhereInput): [User!]!
}

enum SortOrder {
  asc
  desc
}

input StringFieldUpdateOperationsInput {
  set: String
}

input StringFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableFilter {
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableFilter
  notIn: [String!]
  startsWith: String
}

input StringNullableWithAggregatesFilter {
  _count: NestedIntNullableFilter
  _max: NestedStringNullableFilter
  _min: NestedStringNullableFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringNullableWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

input StringWithAggregatesFilter {
  _count: NestedIntFilter
  _max: NestedStringFilter
  _min: NestedStringFilter
  contains: String
  endsWith: String
  equals: String
  gt: String
  gte: String
  in: [String!]
  lt: String
  lte: String
  not: NestedStringWithAggregatesFilter
  notIn: [String!]
  startsWith: String
}

type User {
  _count: UserCount
  email: String
  firstName: String!
  id: String!
  lastName: String!
  orders(cursor: OrderWhereUniqueInput, distinct: [OrderScalarFieldEnum!], orderBy: [OrderOrderByWithRelationInput!], skip: Int, take: Int, where: OrderWhereInput): [Order!]!
  password: String
  providers(cursor: UserProviderWhereUniqueInput, distinct: [UserProviderScalarFieldEnum!], orderBy: [UserProviderOrderByWithRelationInput!], skip: Int, take: Int, where: UserProviderWhereInput): [UserProvider!]!
}

type UserCount {
  orders: Int!
  providers: Int!
}

type UserCountAggregate {
  _all: Int!
  email: Int!
  firstName: Int!
  id: Int!
  lastName: Int!
  password: Int!
}

input UserCountOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
}

input UserCreateInput {
  email: String
  firstName: String!
  id: String
  lastName: String!
  orders: OrderCreateNestedManyWithoutUserInput
  password: String
  providers: UserProviderCreateNestedManyWithoutUserInput
}

input UserCreateManyInput {
  email: String
  firstName: String!
  id: String
  lastName: String!
  password: String
}

input UserCreateNestedOneWithoutOrdersInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutOrdersInput
  create: UserCreateWithoutOrdersInput
}

input UserCreateNestedOneWithoutProvidersInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProvidersInput
  create: UserCreateWithoutProvidersInput
}

input UserCreateOrConnectWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput!
  where: UserWhereUniqueInput!
}

input UserCreateOrConnectWithoutProvidersInput {
  create: UserCreateWithoutProvidersInput!
  where: UserWhereUniqueInput!
}

input UserCreateWithoutOrdersInput {
  email: String
  firstName: String!
  id: String
  lastName: String!
  password: String
  providers: UserProviderCreateNestedManyWithoutUserInput
}

input UserCreateWithoutProvidersInput {
  email: String
  firstName: String!
  id: String
  lastName: String!
  orders: OrderCreateNestedManyWithoutUserInput
  password: String
}

type UserGroupBy {
  _count: UserCountAggregate
  _max: UserMaxAggregate
  _min: UserMinAggregate
  email: String
  firstName: String!
  id: String!
  lastName: String!
  password: String
}

type UserMaxAggregate {
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
}

input UserMaxOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
}

type UserMinAggregate {
  email: String
  firstName: String
  id: String
  lastName: String
  password: String
}

input UserMinOrderByAggregateInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
}

input UserOrderByWithAggregationInput {
  _count: UserCountOrderByAggregateInput
  _max: UserMaxOrderByAggregateInput
  _min: UserMinOrderByAggregateInput
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  password: SortOrder
}

input UserOrderByWithRelationInput {
  email: SortOrder
  firstName: SortOrder
  id: SortOrder
  lastName: SortOrder
  orders: OrderOrderByRelationAggregateInput
  password: SortOrder
  providers: UserProviderOrderByRelationAggregateInput
}

type UserProvider {
  facebookEmail: String
  facebookToken: String
  id: String!
  provider: String!
  providerId: String!
  user: User!
  userId: String!
}

type UserProviderCountAggregate {
  _all: Int!
  facebookEmail: Int!
  facebookToken: Int!
  id: Int!
  provider: Int!
  providerId: Int!
  userId: Int!
}

input UserProviderCountOrderByAggregateInput {
  facebookEmail: SortOrder
  facebookToken: SortOrder
  id: SortOrder
  provider: SortOrder
  providerId: SortOrder
  userId: SortOrder
}

input UserProviderCreateInput {
  facebookEmail: String
  facebookToken: String
  id: String
  provider: String!
  providerId: String!
  user: UserCreateNestedOneWithoutProvidersInput!
}

input UserProviderCreateManyInput {
  facebookEmail: String
  facebookToken: String
  id: String
  provider: String!
  providerId: String!
  userId: String!
}

input UserProviderCreateManyUserInput {
  facebookEmail: String
  facebookToken: String
  id: String
  provider: String!
  providerId: String!
}

input UserProviderCreateManyUserInputEnvelope {
  data: [UserProviderCreateManyUserInput!]!
  skipDuplicates: Boolean
}

input UserProviderCreateNestedManyWithoutUserInput {
  connect: [UserProviderWhereUniqueInput!]
  connectOrCreate: [UserProviderCreateOrConnectWithoutUserInput!]
  create: [UserProviderCreateWithoutUserInput!]
  createMany: UserProviderCreateManyUserInputEnvelope
}

input UserProviderCreateOrConnectWithoutUserInput {
  create: UserProviderCreateWithoutUserInput!
  where: UserProviderWhereUniqueInput!
}

input UserProviderCreateWithoutUserInput {
  facebookEmail: String
  facebookToken: String
  id: String
  provider: String!
  providerId: String!
}

type UserProviderGroupBy {
  _count: UserProviderCountAggregate
  _max: UserProviderMaxAggregate
  _min: UserProviderMinAggregate
  facebookEmail: String
  facebookToken: String
  id: String!
  provider: String!
  providerId: String!
  userId: String!
}

input UserProviderListRelationFilter {
  every: UserProviderWhereInput
  none: UserProviderWhereInput
  some: UserProviderWhereInput
}

type UserProviderMaxAggregate {
  facebookEmail: String
  facebookToken: String
  id: String
  provider: String
  providerId: String
  userId: String
}

input UserProviderMaxOrderByAggregateInput {
  facebookEmail: SortOrder
  facebookToken: SortOrder
  id: SortOrder
  provider: SortOrder
  providerId: SortOrder
  userId: SortOrder
}

type UserProviderMinAggregate {
  facebookEmail: String
  facebookToken: String
  id: String
  provider: String
  providerId: String
  userId: String
}

input UserProviderMinOrderByAggregateInput {
  facebookEmail: SortOrder
  facebookToken: SortOrder
  id: SortOrder
  provider: SortOrder
  providerId: SortOrder
  userId: SortOrder
}

input UserProviderOrderByRelationAggregateInput {
  _count: SortOrder
}

input UserProviderOrderByWithAggregationInput {
  _count: UserProviderCountOrderByAggregateInput
  _max: UserProviderMaxOrderByAggregateInput
  _min: UserProviderMinOrderByAggregateInput
  facebookEmail: SortOrder
  facebookToken: SortOrder
  id: SortOrder
  provider: SortOrder
  providerId: SortOrder
  userId: SortOrder
}

input UserProviderOrderByWithRelationInput {
  facebookEmail: SortOrder
  facebookToken: SortOrder
  id: SortOrder
  provider: SortOrder
  providerId: SortOrder
  user: UserOrderByWithRelationInput
  userId: SortOrder
}

enum UserProviderScalarFieldEnum {
  facebookEmail
  facebookToken
  id
  provider
  providerId
  userId
}

input UserProviderScalarWhereInput {
  AND: [UserProviderScalarWhereInput!]
  NOT: [UserProviderScalarWhereInput!]
  OR: [UserProviderScalarWhereInput!]
  facebookEmail: StringNullableFilter
  facebookToken: StringNullableFilter
  id: StringFilter
  provider: StringFilter
  providerId: StringFilter
  userId: StringFilter
}

input UserProviderScalarWhereWithAggregatesInput {
  AND: [UserProviderScalarWhereWithAggregatesInput!]
  NOT: [UserProviderScalarWhereWithAggregatesInput!]
  OR: [UserProviderScalarWhereWithAggregatesInput!]
  facebookEmail: StringNullableWithAggregatesFilter
  facebookToken: StringNullableWithAggregatesFilter
  id: StringWithAggregatesFilter
  provider: StringWithAggregatesFilter
  providerId: StringWithAggregatesFilter
  userId: StringWithAggregatesFilter
}

input UserProviderUpdateInput {
  facebookEmail: NullableStringFieldUpdateOperationsInput
  facebookToken: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerId: StringFieldUpdateOperationsInput
  user: UserUpdateOneRequiredWithoutProvidersNestedInput
}

input UserProviderUpdateManyMutationInput {
  facebookEmail: NullableStringFieldUpdateOperationsInput
  facebookToken: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerId: StringFieldUpdateOperationsInput
}

input UserProviderUpdateManyWithWhereWithoutUserInput {
  data: UserProviderUpdateManyMutationInput!
  where: UserProviderScalarWhereInput!
}

input UserProviderUpdateManyWithoutUserNestedInput {
  connect: [UserProviderWhereUniqueInput!]
  connectOrCreate: [UserProviderCreateOrConnectWithoutUserInput!]
  create: [UserProviderCreateWithoutUserInput!]
  createMany: UserProviderCreateManyUserInputEnvelope
  delete: [UserProviderWhereUniqueInput!]
  deleteMany: [UserProviderScalarWhereInput!]
  disconnect: [UserProviderWhereUniqueInput!]
  set: [UserProviderWhereUniqueInput!]
  update: [UserProviderUpdateWithWhereUniqueWithoutUserInput!]
  updateMany: [UserProviderUpdateManyWithWhereWithoutUserInput!]
  upsert: [UserProviderUpsertWithWhereUniqueWithoutUserInput!]
}

input UserProviderUpdateWithWhereUniqueWithoutUserInput {
  data: UserProviderUpdateWithoutUserInput!
  where: UserProviderWhereUniqueInput!
}

input UserProviderUpdateWithoutUserInput {
  facebookEmail: NullableStringFieldUpdateOperationsInput
  facebookToken: NullableStringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  provider: StringFieldUpdateOperationsInput
  providerId: StringFieldUpdateOperationsInput
}

input UserProviderUpsertWithWhereUniqueWithoutUserInput {
  create: UserProviderCreateWithoutUserInput!
  update: UserProviderUpdateWithoutUserInput!
  where: UserProviderWhereUniqueInput!
}

input UserProviderWhereInput {
  AND: [UserProviderWhereInput!]
  NOT: [UserProviderWhereInput!]
  OR: [UserProviderWhereInput!]
  facebookEmail: StringNullableFilter
  facebookToken: StringNullableFilter
  id: StringFilter
  provider: StringFilter
  providerId: StringFilter
  user: UserRelationFilter
  userId: StringFilter
}

input UserProviderWhereUniqueInput {
  id: String
}

input UserRelationFilter {
  is: UserWhereInput
  isNot: UserWhereInput
}

enum UserScalarFieldEnum {
  email
  firstName
  id
  lastName
  password
}

input UserScalarWhereWithAggregatesInput {
  AND: [UserScalarWhereWithAggregatesInput!]
  NOT: [UserScalarWhereWithAggregatesInput!]
  OR: [UserScalarWhereWithAggregatesInput!]
  email: StringNullableWithAggregatesFilter
  firstName: StringWithAggregatesFilter
  id: StringWithAggregatesFilter
  lastName: StringWithAggregatesFilter
  password: StringNullableWithAggregatesFilter
}

input UserUpdateInput {
  email: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  orders: OrderUpdateManyWithoutUserNestedInput
  password: NullableStringFieldUpdateOperationsInput
  providers: UserProviderUpdateManyWithoutUserNestedInput
}

input UserUpdateManyMutationInput {
  email: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
}

input UserUpdateOneRequiredWithoutOrdersNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutOrdersInput
  create: UserCreateWithoutOrdersInput
  update: UserUpdateWithoutOrdersInput
  upsert: UserUpsertWithoutOrdersInput
}

input UserUpdateOneRequiredWithoutProvidersNestedInput {
  connect: UserWhereUniqueInput
  connectOrCreate: UserCreateOrConnectWithoutProvidersInput
  create: UserCreateWithoutProvidersInput
  update: UserUpdateWithoutProvidersInput
  upsert: UserUpsertWithoutProvidersInput
}

input UserUpdateWithoutOrdersInput {
  email: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  password: NullableStringFieldUpdateOperationsInput
  providers: UserProviderUpdateManyWithoutUserNestedInput
}

input UserUpdateWithoutProvidersInput {
  email: NullableStringFieldUpdateOperationsInput
  firstName: StringFieldUpdateOperationsInput
  id: StringFieldUpdateOperationsInput
  lastName: StringFieldUpdateOperationsInput
  orders: OrderUpdateManyWithoutUserNestedInput
  password: NullableStringFieldUpdateOperationsInput
}

input UserUpsertWithoutOrdersInput {
  create: UserCreateWithoutOrdersInput!
  update: UserUpdateWithoutOrdersInput!
}

input UserUpsertWithoutProvidersInput {
  create: UserCreateWithoutProvidersInput!
  update: UserUpdateWithoutProvidersInput!
}

input UserWhereInput {
  AND: [UserWhereInput!]
  NOT: [UserWhereInput!]
  OR: [UserWhereInput!]
  email: StringNullableFilter
  firstName: StringFilter
  id: StringFilter
  lastName: StringFilter
  orders: OrderListRelationFilter
  password: StringNullableFilter
  providers: UserProviderListRelationFilter
}

input UserWhereUniqueInput {
  email: String
  id: String
}
